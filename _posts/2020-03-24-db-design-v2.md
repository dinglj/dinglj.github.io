---
layout : post
title : "数据库规范V2"
category : 规范V2
duoshuo: true
date : 2020-03-24
tags : [数据库,设计规范]
---
八大约定：
1、禁止创建无主键的表，推荐使用 UNSIGNED INT / UNSIGNED BIGINT AUTO_INCREMENT 类型主键
2、禁止使用MyISAM存储引擎；使用默认InnoDB即可，建表时显式指定；其他存储引擎（如TokuDB，RocksDB），请与DBA沟通
3.统一使用utf8字符集，若需要emoji支持，使用utf8mb4字符集，其它编码方式不支持
4.禁止在数据库中存储图片、视频等大对象
5.禁止使用自定义函数、存储过程、触发器、外键
6.避免直接使用delete语句删除数据，推荐使用标记删除，必须执行物理删除时，需先对数据打标
7.禁止删除字段，业务上废弃使用即可，并添加注释
8.避免修改字段名称，字段类型，有此需求需要提前沟通所有上下游

风险预防：

1.禁止 SELECT * 查询，SQL必须显式指定返回字段，避免加载不必要的数据，及字段变化导致不可知问题、统计整天数据时不要用<=23:59:59得方式，使用<date+1:00:00:00
2.严禁字符串拼接方式执行SQL，避免SQL注入，请使用prepared statement
程序中有批量更新/删除大量数据（超过10w行）需求的，必须提前和DBA沟通确认方案
3.更新/删除数据必须走索引，单次更新/删除不应超过10w行
4.两次10w行数据更新/删除之间必须sleep 10秒以上，以确保备库延迟在一定范围内
5.P0系统直接面向C端用户高并发场景接口，禁止使用多表join，非P0业务中必须使用join时，join的表个数不能超过3个，且确保每个表上的join字段必须能够使用到索引
6.多表join时，随着表中数据量的变化，执行计划会不稳定，存在性能陡降风险，在高并发场景下，可能引发雪崩！！！
7.join在MySQL中耗费CPU和IO，且扩展性差，拆分成简单SQL后可以更好利用多核CPU提高并发性能
8.返回多条数据的查询，SQL一律带上LIMIT条件，且上限不超过1000（如：LIMIT 10， LIMIT 100等，上限1000基本可满足绝大多数后台分页展示、前台API服务需求），以主动规避潜在返回全表数据风险（
批量查询或在线导数据需求（实际此类需求不多），提前与DBA协商，通过新增单独备库实例的方式满足业务，避免影响生产业务
9、同一张表得多个ddl操作要合并为一个sql语句

库表设计：

库名/表名/字段名长度控制在30字符内，全部小写，单词之间使用’_’连接，单词尽量为名词
为新建表添加注释，为新建字段添加注释
定义字段为NOT NULL，并显式声明默认值
避免使用float/double类型，小数使用decimal类型
TINYINT/SMALL INT/INT/BIGINT字段无须指定长度，如：使用INT，而不是INT(4)，尽量使用更小的类型
在VARCHAR类型单个字段上创建索引需保证长度不超过255字符，可建合适的前缀索引(区分度可以由count(distinct left(col,n))计算出来) 
VARCHAR类型最大长度65536字节，长度超过5000的VARCHAR类型，建议使用BLOB/TEXT类型
精确到秒的时间类型选择TIMESTAMP(4 bytes，时间不能早于1970-01-01或晚于2038-01-19)，或者DATETIME(5 bytes，MySQL 5.6.4+)  使用整型作为状态标识的字段定义必须有精确的注释，注释必须UTF8编码
新增字段默认加在最后面即可，不使用『AFTER』或『BEFORE』指定位置（update 2016-12-01）

表中存在大字段时，建议单独创建表存储，并使用id引用
写入JSON类型字段，提前将JSON字符串中的空值field移除，详情
每个表必须包含created/modified/yn字段，分别表示记录创建时间、更新时间、记录标志，并让数据库自动维护created/modified字段（update 2018-04-24）
created：datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'
modified：datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间'
关于yn字段的约定
yn = -1 / 0: 数据无效、或者被标记为逻辑删除
yn = 1: 数据有效（正常情况下，绝大多数记录的取值）
yn = 2: 数据有效，且可做归档（迁移数据到历史库不影响业务，比如3个月前的已完成订单，作为提交给DBA归档数据的依据）
yn = 3: 数据无效，且可做归档（迁移数据到历史库不影响业务，比如3个月前手工订正逻辑删除的订单，作为提交给DBA归档数据的依据）
yn = 4: 数据被标记为物理删除，执行delete之前的打标（update+delete），以便大数据ETL识别
yn = 5,  6，7，8，9，10，11，12，13，14，15，16： 保留取值，用于后续扩展，不建议使用
yn > 16: 业务可以自己定义含义及用途
物理删除前对数据进行打标：（update+delete）更新字段 yn = 4 将数据标记为物理删除；然后再执行delete
性能方面考虑，单表数据不超过1亿条记录 / 100GB，单库数据不超过1TB


索引与SQL优化：

索引命名规则，普通索引：idx_column1_column2_…，唯一索引：uk_column1_column2_…
主键尽量简短，能用INT就不用BIGINT，避免使用多字段主键，AUTO_INCREMNT类型主键在绝大多数情况下都是最佳实践，无特殊原因请遵守
单表上的索引尽量控制在5个以内，减少不必要的索引，保证insert/update/delete效率
利用联合索引减少索引个数，如：索引(a, b)存在了就不再需要索引(a)了 
联合索引字段个数不超过5个，除非能够巧妙利用二级索引覆盖扫描
ORDER BY,GROUP BY,DISTINCT后的字段需要添加索引
绝对避免ORDER BY RAND()
WHERE条件中右值使用和字段定义相同的类型，避免隐式类型转换导致索引失效
避免在SQL中执行数学运算，将原始字段返回后在程序中处理
避免union + limit + order by
避免LIKE ‘%stringxxx’类型查询，其无法使用到索引
分页查询通过将其转化为inner join提高新能，参考
InnoDB的count(*)会触发全表或二级索引上的全表扫描，程序中尽量避免使用



使用explain检查复杂SQL的执行计划，确保每个表都能使用到索引，且rows和extra列不出现影响性能的提示

禁止在limit时count(*)统计数据，没有意义。禁止超过三个表的join。禁止在where条件中对字段使用函数，这样会导致用不上该字段上的索引。
禁止在count(*)统计数据时使用order by，因为会带来额外的开销

禁止出现in(子查询)这种sql，采用表关联的方式处理或者先查询出子查询的结果，再去访问主表数据，同时in（常量元素）这种情况需要仔细评估常量元素的数量，前端应用需数量不能超过50个，定时任务数量不能超过1000。禁止使用not in，它无法使用上索引。

尽可能不要直接 SELECT * 读取全部字段，尤其是表中存在 TEXT/BLOB 大列的时候。
可能本来不需要读取这些列，但因为偷懒写成 SELECT * 导致内存buffer pool被这些“垃圾”数据
把真正需要缓冲起来的热点数据给洗出去了
对单表的多次alter操作必须合并为⼀次操作,
批量导⼊、导出数据必须提前通知DBA协助观察,不在MySQL数据库中存放业务逻辑,提交线上建表改表需求，必须详细注明所有相关SQL语句
